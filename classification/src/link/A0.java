package link;

/**
 * Author:yaozhiyuan0117@163.com
 * Time:2020/5/2 10:30
 * 链表
 */
public class A0 {
    /**
     *
     * 1. 链表反转 （递归，stack）+哨兵
     * 2. 链表每k个元素反转，stack+while循环
     * 3. 判断链表是否回文：快慢指针+反转
     * 4. 链表重新排序，要求time: nlogN,space: 1; 快慢指针+归并
     * 5. 链表是否有环及环的入口? 快慢指针+slow从头开始
     * 6. 链表中倒数第k个节点: 双指针
     * 7. 合并两个递增的链表，
     * 8. 复制复杂链表并返回结果为复制后复杂链表的head。
     *      三步：1. 复制每个元素1-1-2-2-3-3； 2.复制复杂链表 3. 剔除原来的元素。
     * 9. 输入两个链表，找出它们的第一个公共结点。 a+c+b = b+c+a. 两个指针，每个跑到底之后从另一头开始
     * 10. 链表的插入排序； 注意：哨兵的使用。
     *
     * 12. 返回链表的中间值或者上中间值(偶数)
     * 13. 链表回文结构: 可以使用反转或者链表
     * 14. 将单链表划按某值分成左边小，中间相等，右边大的形式
     * 15. 复制链表，链表含有下一个节点和一个random随机节点。
     *
     * 16. 给定两个有环也可能无环的单链表，头节点head1, head2，
     *  请实现一个函数，如果两个链表相交，请返回相交的第一个节点；
     *  如果不相交，返回null. 复合问题！！
     *
     */
}
